# -*- coding: utf-8 -*-
"""Proyek-Creating-Model-Recommendation-System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t2Aub9EJd1a1RRipcwKDmWJYZm0nUybD

# Proyek Creating Model Recommendation System :

- **Nama:** Akbar Widianto
- **Email:** wdntoakbar@gmail.com
- **ID Dicoding:** wakbarr

# Data Understanding

## Memuat Dataset dari File Lokal

### memuat dataset dari file lokal menggunakan library pandas.
"""

import pandas as pd
import pandas as pd
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Memuat dataset dari file lokal
data_film = pd.read_csv('film_indo.csv')

# Menampilkan 5 baris pertama untuk memeriksa data
print(data_film.head())

"""## Menambahkan Kolom user_id

### Untuk mendukung proses Collaborative Filtering, saya tambahkan kolom user_id sebagai identifikasi unik untuk setiap entri.
"""

# Menambahkan kolom user_id secara unik
data_film['user_id'] = ['U' + str(i).zfill(3) for i in range(1, len(data_film) + 1)]

# Menampilkan dataset dengan kolom baru
print(data_film)

"""## Deskripsi Variabel dalam Dataset

### Berikut adalah penjelasan mengenai kolom-kolom dalam dataset:

- `movie_id`: ID unik film sesuai dengan yang ada di IMDb.
- `title`: Judul film.
- `year`: Tahun rilis film.
- `description`: Sinopsis singkat mengenai film.
- `genre`: Genre film.
- `rating`: Rating usia film.
- `users_rating`: Rata-rata rating dari pengguna yang memberikan ulasan.
- `votes`: Jumlah pengguna yang memberikan rating terhadap film.
- `languages`: Bahasa yang digunakan dalam film.
- `directors`: Nama sutradara film.
- `actors`: Daftar pemeran utama dalam film.
- `runtime`: Durasi film dalam menit.
- `user_id`: ID unik pengguna.

## Analisis Awal Dataset

### memeriksa informasi dasar dataset, seperti jumlah data dan tipe data.
"""

# Menampilkan informasi dataset
data_film.info()

# Menghitung jumlah film unik dan genre
print(f"Jumlah film unik: {len(data_film['movie_id'].unique())}")
print(f"Jumlah genre unik: {len(data_film['genre'].unique())}")
print(f"Daftar genre: {data_film['genre'].unique()}")
print(f"Jumlah rating unik: {len(data_film['users_rating'].unique())}")

"""### Hasil yang diharapkan:

Total film: 1.272 entri unik.
Total genre: 16 jenis genre (contoh: Drama, Comedy, Horror, dll.).

## Statistik Deskriptif

### Untuk memahami distribusi rating, menggunakan fungsi describe().
"""

# Menampilkan statistik deskriptif
data_film.describe()

"""### Temuan:

Rating pengguna berkisar antara 1.2 hingga 9.4, yang menunjukkan variasi penilaian yang cukup luas.

# Data Preparation

## Menangani Missing Value

### periksa apakah ada data yang hilang dalam dataset.
"""

# Memeriksa missing value
data_film.isnull().sum()

"""### Jika terdapat missing value (misalnya pada kolom description, genre, atau runtime), kita akan menghapus baris yang bermasalah karena tidak memungkinkan untuk mengisi data secara akurat tanpa informasi tambahan."""

# Menghapus baris dengan missing value
movies_clean = data_film.dropna()

# Memastikan data sudah bersih
movies_clean.isnull().sum()

"""## Menstandardisasi Genre

### pastikan setiap film hanya memiliki satu genre utama untuk mempermudah Content-Based Filtering.
"""

# Mengurutkan berdasarkan movie_id
data_sorted = movies_clean.sort_values('movie_id', ascending=True)

# Memeriksa daftar genre unik
data_sorted['genre'].unique()

# Contoh: Memeriksa film dengan genre 'Thriller'
data_sorted[data_sorted['genre'] == 'Thriller']

"""## Menyiapkan Data untuk Pemodelan

### uat dataset baru yang hanya berisi kolom penting dan hapus duplikat.
"""

# Menghapus duplikat berdasarkan movie_id
data_prepared = data_sorted.drop_duplicates('movie_id')

# Mengonversi kolom ke dalam bentuk list
id_film = data_prepared['movie_id'].tolist()
nama_film = data_prepared['title'].tolist()
genre_film = data_prepared['genre'].tolist()

# Membuat DataFrame baru
data_final = pd.DataFrame({
    'id': id_film,
    'nama_film': nama_film,
    'genre': genre_film
})

# Menampilkan data
data_final.head()

"""### Data kini siap untuk digunakan dalam proses pemodelan.

# Pengembangan Model dengan Content-Based Filtering

## Representasi Fitur dengan TF-IDF

### gunakan TfidfVectorizer untuk mengubah data genre menjadi representasi numerik.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi TF-IDF
tfidf = TfidfVectorizer()

# Melatih TF-IDF pada kolom genre
tfidf.fit(data_final['genre'])

# Transformasi data ke matriks TF-IDF
tfidf_matriks = tfidf.fit_transform(data_final['genre'])

# Melihat dimensi matriks
print(f"Dimensi matriks TF-IDF: {tfidf_matriks.shape}")

"""### Penjelasan:

Dimensi matriks menunjukkan jumlah film (baris) dan jumlah genre unik (kolom).

## Menghitung Kesamaan dengan Cosine Similarity

### hitung kesamaan antar-film berdasarkan matriks TF-IDF.
"""

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity
kesamaan = cosine_similarity(tfidf_matriks)

# Membuat DataFrame kesamaan
df_kesamaan = pd.DataFrame(kesamaan, index=data_final['nama_film'], columns=data_final['nama_film'])

# Menampilkan sampel
df_kesamaan.sample(5, axis=1).sample(5, axis=0)

"""### Penjelasan:

Nilai 1.0 menunjukkan dua film memiliki genre yang sama.
Nilai mendekati 0 menunjukkan perbedaan genre.

## Fungsi Rekomendasi Film

### buat fungsi untuk memberikan rekomendasi berdasarkan nama film.
"""

def rekomendasi_film(nama_film, data_kesamaan=df_kesamaan, data_film=data_final[['nama_film', 'genre']], jumlah=5):
    # Mengambil indeks film dengan kesamaan tertinggi
    indeks = data_kesamaan.loc[:, nama_film].to_numpy().argpartition(range(-1, -jumlah, -1))
    film_terdekat = data_kesamaan.columns[indeks[-1:-(jumlah+2):-1]]

    # Menghapus film yang dicari dari hasil rekomendasi
    film_terdekat = film_terdekat.drop(nama_film, errors='ignore')

    # Mengembalikan hasil rekomendasi
    return pd.DataFrame(film_terdekat).merge(data_film).head(jumlah)

# Contoh penggunaan
rekomendasi_film('MeloDylan')

"""### Hasil:

Fungsi ini akan mengembalikan 5 film dengan genre serupa (misalnya, Drama) berdasarkan film yang dipilih.

# Pengembangan Model dengan Collaborative Filtering

## Persiapan Data

### siapkan data dengan hanya menyisakan kolom yang relevan.
"""

# Memilih kolom yang diperlukan
data_cf = data_film[['movie_id', 'user_id', 'users_rating']].drop_duplicates()

# Encoding user_id dan movie_id
user_unik = data_cf['user_id'].unique().tolist()
user_ke_indeks = {val: idx for idx, val in enumerate(user_unik)}
movie_unik = data_cf['movie_id'].unique().tolist()
movie_ke_indeks = {val: idx for idx, val in enumerate(movie_unik)}

# Mapping ke DataFrame
data_cf['user'] = data_cf['user_id'].map(user_ke_indeks)
data_cf['movie'] = data_cf['movie_id'].map(movie_ke_indeks)

# Informasi jumlah user dan film
jumlah_user = len(user_ke_indeks)
jumlah_film = len(movie_ke_indeks)
print(f"Jumlah user: {jumlah_user}, Jumlah film: {jumlah_film}")

# Normalisasi rating ke skala 0-1
data_cf['users_rating'] = data_cf['users_rating'].astype(float)
min_rating = data_cf['users_rating'].min()
max_rating = data_cf['users_rating'].max()

"""## Membagi Data untuk Pelatihan dan Validasi

### bagi data menjadi 80% untuk pelatihan dan 20% untuk validasi.
"""

# Mengacak data
data_cf = data_cf.sample(frac=1, random_state=42)

# Membuat input (x) dan target (y)
x = data_cf[['user', 'movie']].values
y = data_cf['users_rating'].apply(lambda r: (r - min_rating) / (max_rating - min_rating)).values

# Membagi data
indeks_pelatihan = int(0.8 * len(data_cf))
x_train, x_val = x[:indeks_pelatihan], x[indeks_pelatihan:]
y_train, y_val = y[:indeks_pelatihan], y[indeks_pelatihan:]

"""## Membangun Model

### gunakan TensorFlow untuk membuat model Collaborative Filtering.
"""

import tensorflow as tf
from tensorflow.keras import layers

class ModelRekomendasi(tf.keras.Model):
    def __init__(self, num_users, num_movies, embedding_dim):
        super().__init__()
        self.user_emb = layers.Embedding(num_users, embedding_dim, embeddings_initializer='he_normal', embeddings_regularizer=tf.keras.regularizers.l2(1e-6))
        self.user_bias = layers.Embedding(num_users, 1)
        self.movie_emb = layers.Embedding(num_movies, embedding_dim, embeddings_initializer='he_normal', embeddings_regularizer=tf.keras.regularizers.l2(1e-6))
        self.movie_bias = layers.Embedding(num_movies, 1)

    def call(self, inputs):
        user_vec = self.user_emb(inputs[:, 0])
        user_b = self.user_bias(inputs[:, 0])
        movie_vec = self.movie_emb(inputs[:, 1])
        movie_b = self.movie_bias(inputs[:, 1])
        dot = tf.tensordot(user_vec, movie_vec, 2)
        output = dot + user_b + movie_b
        return tf.nn.sigmoid(output)

# Inisialisasi dan kompilasi model
model = ModelRekomendasi(jumlah_user, jumlah_film, 50)
model.compile(
    loss=tf.keras.losses.BinaryCrossentropy(),
    optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

# Melatih model
history = model.fit(
    x=x_train, y=y_train,
    batch_size=8, epochs=100,
    validation_data=(x_val, y_val)
)

"""## Visualisasi Hasil Pelatihan

### visualisasikan metrik RMSE untuk mengevaluasi performa model.
"""

import matplotlib.pyplot as plt

plt.plot(history.history['root_mean_squared_error'], label='Train RMSE')
plt.plot(history.history['val_root_mean_squared_error'], label='Validation RMSE')
plt.title('Evaluasi Model')
plt.xlabel('Epoch')
plt.ylabel('Root Mean Squared Error')
plt.legend()
plt.show()

"""## Menghasilkan Rekomendasi

### buat rekomendasi untuk pengguna tertentu.

### Debugging Data Awal
"""

# Cetak beberapa informasi untuk debugging
print(f"Jumlah movie_id unik di data_cf: {len(data_cf['movie_id'].unique())}")
print(f"Jumlah id unik di data_final: {len(data_final['id'].unique())}")
print(f"Contoh film_rekomendasi: {film_rekomendasi[:5]}")
print(f"Contoh id di data_final: {data_final['id'].head().tolist()}")

"""### Memastikan Konsistensi Data"""

# Filter film_rekomendasi agar hanya menyertakan id yang ada di data_final
film_rekomendasi = [film_id for film_id in film_rekomendasi if film_id in data_final['id'].values]

"""### Menangani Kasus Kosong dengan Pengecekan"""

print("\n10 Rekomendasi Film:")
for film_id in film_rekomendasi:
    detail = data_final[data_final['id'] == film_id]
    if not detail.empty:
        print(f"{detail['nama_film'].iloc[0]} (Genre: {detail['genre'].iloc[0]})")
    else:
        print(f"Film dengan ID {film_id} tidak ditemukan di data_final")

# Memilih pengguna acak
user_id = data_cf['user_id'].sample(1).iloc[0]
film_dilihat = data_cf[data_cf['user_id'] == user_id]

# Film yang belum dilihat
film_belum_dilihat = data_final[~data_final['id'].isin(film_dilihat['movie_id'])]['id']
film_belum_dilihat = list(set(film_belum_dilihat).intersection(movie_ke_indeks.keys()))
film_belum_dilihat = [[movie_ke_indeks.get(film)] for film in film_belum_dilihat]

# Menyiapkan input untuk prediksi
user_indeks = user_ke_indeks.get(user_id)
input_prediksi = np.hstack(([[user_indeks]] * len(film_belum_dilihat), film_belum_dilihat))

# Memprediksi rating
prediksi = model.predict(input_prediksi).flatten()
indeks_top = prediksi.argsort()[-10:][::-1]
film_rekomendasi = [movie_unik[i] for i in indeks_top]

# Filter film_rekomendasi agar hanya yang ada di data_final
film_rekomendasi = [film_id for film_id in film_rekomendasi if film_id in data_final['id'].values]

# Menampilkan hasil
print(f"Rekomendasi untuk pengguna {user_id}:")
print("Film yang disukai pengguna:")
for film in film_dilihat.sort_values(by='users_rating', ascending=False).head(5).itertuples():
    detail = data_final[data_final['id'] == film.movie_id]
    if not detail.empty:
        print(f"{detail['nama_film'].iloc[0]} (Genre: {detail['genre'].iloc[0]})")
    else:
        print(f"Film dengan ID {film.movie_id} tidak ditemukan")

print("\n10 Rekomendasi Film:")
for film_id in film_rekomendasi:
    detail = data_final[data_final['id'] == film_id]
    if not detail.empty:
        print(f"{detail['nama_film'].iloc[0]} (Genre: {detail['genre'].iloc[0]})")
    else:
        print(f"Film dengan ID {film_id} tidak ditemukan di data_final")